Disassembly Listing for pic12f675_eval
Generated From:
C:/Users/Peter/Documents/pic12f675_eval.X/dist/default/production/pic12f675_eval.X.production.cof
15.5.2019 23:29:08

---  C:/Users/Peter/Documents/pic12f675_eval.X/main.c  --------------------------------------------------
1:             /* 
2:              * File:   main.c
3:              * Author: Peter
4:              *
5:              * Created on 24. april 2019, 0:12
6:              */
7:             
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <stdint.h>
11:            //#include <pic12f675.h>
12:            
13:            #include <htc.h>
14:            
15:            #include "GPIO_driver.h"
16:            
17:            #include "hw_timer0.h"
18:            #include "interrupt.h"
19:            
20:            #define TIMER0_1S_CONST         (242u)
21:            #define TIMER0_0_5S_CONST       (121u)
22:            
23:            
24:            __CONFIG(FOSC_INTRCIO & WDTE_OFF & PWRTE_OFF & MCLRE_ON & BOREN_ON & CP_OFF & CPD_OFF);
25:            
26:            
27:            void delay_blk(uint16_t delay_cnt);
28:            
29:            /*
30:             * GLOBAL VARIABLES:
31:             */
32:            //static uint8_t timer0_cnt = TIMER0_1S_CONST;
33:            
34:            void tmr0_sw_intHandler(void)
35:            {
36:                static uint8_t timer0_cnt = 0;
37:                timer0_cnt--;
0052  3001     MOVLW 0x1
0053  1283     BCF STATUS, 0x5
0054  02AF     SUBWF timer0_cnt, F
38:                if(timer0_cnt == 0) {
0055  08AF     MOVF timer0_cnt, F
0056  1D03     BTFSS STATUS, 0x2
0057  2859     GOTO 0x59
0058  285A     GOTO 0x5A
0059  2865     GOTO 0x65
39:                    //timer0_cnt = TIMER0_1S_CONST;
40:                    timer0_cnt = TIMER0_0_5S_CONST;
005A  3079     MOVLW 0x79
005B  00A3     MOVWF 0x23
005C  0823     MOVF 0x23, W
005D  00AF     MOVWF timer0_cnt
41:                    gpio_write(GPIO_PIN_4_Msk, GPIO_TOGGLE); 
005E  3002     MOVLW 0x2
005F  00A3     MOVWF 0x23
0060  0823     MOVF 0x23, W
0061  00A0     MOVWF GPIO_write
0062  3010     MOVLW 0x10
0063  2014     CALL 0x14
0064  2865     GOTO 0x65
42:                }
43:            }
0065  0008     RETURN
44:            
45:            
46:            void delay_blk(uint16_t delay_cnt)
47:            {
48:                while(delay_cnt){
49:                    delay_cnt--;
50:                }
51:            }
52:            
53:            /*
54:             * 
55:             */
56:            int main(int argc, char** argv) {
57:                
58:                static uint8_t gpio_state = (1<<4);
009D  3410     RETLW 0x10
59:                
60:                gpio_init(GPIO_PIN_4_Msk);
008F  3010     MOVLW 0x10
0090  2078     CALL 0x78
61:                intr_tmr0_en();
0091  2085     CALL 0x85
62:                hw_timer0_setup(TIMER0_PRSC_8);
0092  3002     MOVLW 0x2
0093  2066     CALL 0x66
0094  2895     GOTO 0x95
63:                
64:                while(1)
0095  2895     GOTO 0x95
65:                { 
66:                   //gpio_write(GPIO_PIN_4_Msk, GPIO_TOGGLE);
67:                   //delay_blk(20000);
68:                   
69:                    //GPIObits.GP4 = 0;
70:                    //delay_blk(20000);
71:                    //GPIObits.GP4 = 1;
72:                    //delay_blk(10000); 
73:                    //GPIObits.GP4 = !GPIObits.GP4; 
74:                    
75:                    // if(hw_timer0_get_OF_bit()) {
76:                    //     timer0_cnt--;
77:                    //     if(timer0_cnt == 0) {
78:                    //         timer0_cnt = TIMER0_1S_CONST;
79:                    //         gpio_write(GPIO_PIN_4_Msk, GPIO_TOGGLE); 
80:                    //     }
81:                    // }
82:                    
83:                }
84:                return (EXIT_SUCCESS);
85:            }
0096  280F     GOTO 0xF
86:            
---  C:/Users/Peter/Documents/pic12f675_eval.X/interrupt.c  ---------------------------------------------
1:             #include "interrupt.h"
2:             
3:             #include <stdint.h>
4:             #include <pic12f675.h>
5:             
6:             /* 1010 0000  [GIE|TMR0IE] */
7:             #define INTCON_TMR0_SETUP_Msk      (0xA0)
8:             
9:             void intr_tmr0_en(void)
10:            {
11:                // firt clear bits that we will change
12:                INTCON &= (~INTCON_TMR0_SETUP_Msk);
0085  305F     MOVLW 0x5F
0086  1283     BCF STATUS, 0x5
0087  00A8     MOVWF 0x28
0088  0828     MOVF 0x28, W
0089  058B     ANDWF INTCON, F
13:                INTCON |= (INTCON_TMR0_SETUP_Msk);
008A  30A0     MOVLW 0xA0
008B  00A8     MOVWF 0x28
008C  0828     MOVF 0x28, W
008D  048B     IORWF INTCON, F
14:            }
008E  0008     RETURN
15:            
16:            
17:            void interrupt pic_isr(void)
18:            {
0004  00DE     MOVWF 0x5E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  00A4     MOVWF 0x24
0008  0804     MOVF FSR, W
0009  00A5     MOVWF 0x25
000A  080A     MOVF PCLATH, W
000B  00A6     MOVWF 0x26
000C  085F     MOVF 0x5F, W
000D  00A7     MOVWF 0x27
000E  283B     GOTO 0x3B
000F  1683     BSF STATUS, 0x5
0010  23FF     CALL 0x3FF
0011  0090     MOVWF T1CON
0012  0183     CLRF STATUS
0013  2897     GOTO 0x97
19:                // only process timer-triggered interrupts
20:                if(INTCONbits.TMR0IE && INTCONbits.TMR0IF) {
003B  1E8B     BTFSS INTCON, 0x5
003C  283E     GOTO 0x3E
003D  283F     GOTO 0x3F
003E  2846     GOTO 0x46
003F  1D0B     BTFSS INTCON, 0x2
0040  2842     GOTO 0x42
0041  2843     GOTO 0x43
0042  2846     GOTO 0x46
21:                    //portValue++;
22:                    tmr0_sw_intHandler();
0043  2052     CALL 0x52
23:                    INTCONbits.TMR0IF = 0;  // clear this interrupt condition
0044  110B     BCF INTCON, 0x2
0045  2846     GOTO 0x46
24:                }
25:            }
0046  1283     BCF STATUS, 0x5
---  C:/Users/Peter/Documents/pic12f675_eval.X/hw_timer0.c  ---------------------------------------------
1:             #include "hw_timer0.h"
2:             
3:             
4:             #define OPTION_REG_PRSC_Msk         (0x07u)
5:             
6:             void hw_timer0_setup(eTimer0_prsc_t prsc)
7:             {
0066  1283     BCF STATUS, 0x5
0067  00A9     MOVWF 0x29
8:                 TMR0 = 0x00;
0068  0181     CLRF TMR0
9:                 OPTION_REG = 0;
0069  1683     BSF STATUS, 0x5
006A  0181     CLRF TMR0
10:                //OPTION_REGbits.T0CS = 1;
11:                /* clear prescaler bits */
12:                OPTION_REG &= (~OPTION_REG_PRSC_Msk);
006B  30F8     MOVLW 0xF8
006C  1283     BCF STATUS, 0x5
006D  00A8     MOVWF 0x28
006E  0828     MOVF 0x28, W
006F  1683     BSF STATUS, 0x5
0070  0581     ANDWF TMR0, F
13:                /* set prescaler bits*/
14:                OPTION_REG |= (prsc);
0071  1283     BCF STATUS, 0x5
0072  0829     MOVF 0x29, W
0073  00A8     MOVWF 0x28
0074  0828     MOVF 0x28, W
0075  1683     BSF STATUS, 0x5
0076  0481     IORWF TMR0, F
15:                //OPTION_REGbits.T0CS = 0;
16:            
17:                //OPTION_REG = 0x03; // this set prescaler to 16
18:            
19:            }
0077  0008     RETURN
20:            
21:            uint8_t hw_timer0_get_OF_bit(void)
22:            {
23:                if(INTCONbits.T0IF){
24:                    INTCONbits.T0IF = 0;
25:                    return 1;
26:                }else {
27:                    return 0;
28:                }
29:            }
---  C:/Users/Peter/Documents/pic12f675_eval.X/GPIO_driver.c  -------------------------------------------
1:             
2:             #include "htc.h"
3:             #include "GPIO_driver.h"
4:             
5:             
6:             
7:             
8:             void gpio_init(GPIO_pin_msk_t pin_msk){
9:             
10:                TRISIO &= (~pin_msk);
0078  1283     BCF STATUS, 0x5
0079  00A9     MOVWF 0x29
007A  0929     COMF 0x29, W
007B  00A8     MOVWF 0x28
007C  0828     MOVF 0x28, W
007D  1683     BSF STATUS, 0x5
007E  0585     ANDWF GPIO, F
11:                GPIO &= (~pin_msk);
007F  1283     BCF STATUS, 0x5
0080  0929     COMF 0x29, W
0081  00A8     MOVWF 0x28
0082  0828     MOVF 0x28, W
0083  0585     ANDWF GPIO, F
12:            }
0084  0008     RETURN
13:            
14:            void gpio_write(GPIO_pin_msk_t pin_msk, eGPIO_write_t GPIO_write)
15:            {
16:                static uint8_t GPIO_state = 0x00;
17:                
18:                if(GPIO_write == GPIO_HIGH){
0014  1283     BCF STATUS, 0x5
0015  00A2     MOVWF 0x22
0016  0820     MOVF GPIO_write, W
0017  3A01     XORLW 0x1
0018  1D03     BTFSS STATUS, 0x2
0019  281B     GOTO 0x1B
001A  281C     GOTO 0x1C
001B  2821     GOTO 0x21
19:                    GPIO_state |= (pin_msk);
001C  0822     MOVF 0x22, W
001D  00A1     MOVWF 0x21
001E  0821     MOVF 0x21, W
001F  04AE     IORWF GPIO_state, F
20:                    //GPIO |= (pin_msk); // this for some to me unknown reason not work 
21:                }else if(GPIO_write == GPIO_LOW){
0020  2838     GOTO 0x38
0021  08A0     MOVF GPIO_write, F
0022  1D03     BTFSS STATUS, 0x2
0023  2825     GOTO 0x25
0024  2826     GOTO 0x26
0025  282B     GOTO 0x2B
22:                    GPIO_state &= (~pin_msk);
0026  0922     COMF 0x22, W
0027  00A1     MOVWF 0x21
0028  0821     MOVF 0x21, W
0029  05AE     ANDWF GPIO_state, F
23:                    //GPIO &= (~pin_msk);
24:                }else if(GPIO_write == GPIO_TOGGLE){
002A  2838     GOTO 0x38
002B  0820     MOVF GPIO_write, W
002C  3A02     XORLW 0x2
002D  1D03     BTFSS STATUS, 0x2
002E  2830     GOTO 0x30
002F  2831     GOTO 0x31
0030  2838     GOTO 0x38
25:                    GPIO_state ^= (pin_msk);
0031  0822     MOVF 0x22, W
0032  00A1     MOVWF 0x21
0033  0821     MOVF 0x21, W
0034  06AE     XORWF GPIO_state, F
0035  2838     GOTO 0x38
26:                    //GPIO ^= (pin_msk);
27:                }
0036  2838     GOTO 0x38
28:                GPIO = GPIO_state;
0037  2838     GOTO 0x38
0038  082E     MOVF GPIO_state, W
0039  0085     MOVWF GPIO
29:            }
003A  0008     RETURN
